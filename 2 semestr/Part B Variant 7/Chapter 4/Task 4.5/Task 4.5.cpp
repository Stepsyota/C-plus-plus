//  Используя объекты класса «Бинарное дерево»,
//  реализовать алгоритм своего варианта задания
//  2.7 «Учебной вычислительной практики».

#include <iostream>

int main()
{
	make_task_2_7();

	// For check all methods and constructors
	//List<double> v0;
	//cout << "v0:\t";	 v0.output_list();

	//List<double> v1;
	//v1.fill_list(3);
	//cout << "v1:\t";	 v1.output_list();
	//cout << "Size v1: " << v1.get_size() << endl;
	//cout << "Empty v1: " << v1.empty() << endl;
	//cout << "First elem: " << v1.get_node(0) << '\t' << v1.get_node(0)->data << endl;
	//cout << "Adress sentinel: " << v1.get_sentinel() << endl;
	//v1.push_front(rand() % 1000 / 100.0);
	//cout << "v1:\t";	 v1.output_list();
	//v1.push_back(rand() % 1000 / 100.0);
	//cout << "v1:\t";	 v1.output_list();
	//v1.insert_after(v1.get_node(2), rand() % 1000 / 100.0);
	//cout << "v1:\t";	 v1.output_list();
	//v1.insert_before(v1.get_node(3), rand() % 1000 / 100.0);
	//cout << "v1:\t";	 v1.output_list();
	//v1.pop_front();
	//cout << "v1:\t";	 v1.output_list();
	//v1.pop_back();
	//cout << "v1:\t";	 v1.output_list();
	//v1.pop_element(v1.get_node(1));
	//cout << "v1:\t";	 v1.output_list();

	//List<double> v2(v1);
	//cout << "v2:\t";	 v2.output_list();

	//List<double> v3;
	//v3 = v1;
	//cout << "v3:\t";	 v3.output_list();

	//List<double> v4(move(v2));
	//cout << "v4:\t";	 v4.output_list();
	//cout << "v2:\t";	 v2.output_list();

	//List<double> v5;
	//v5 = move(v3);
	//cout << "v5:\t";	 v5.output_list();
	//cout << "v3:\t";	 v3.output_list();

	//v5.find_element(7.05);
	return 0;
}